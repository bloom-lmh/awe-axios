# 依赖注入（Dependency Injection）

在 axios-plus 中，依赖注入（DI）通过 `@Inject` 装饰器与 IoC（控制反转）容器实现，用于解耦组件间的依赖关系，自动管理实例的创建和注入过程。以下是详细实现方式和使用说明：

## 核心概念

- **IoC 容器**：由 `InstanceFactory` 实现，负责管理所有注册的类实例（通过 `@Component` 装饰器注册）。
- **依赖注入**：通过 `@Inject` 装饰器声明依赖，容器自动查找并注入所需实例。
- **实例作用域**：支持多种实例创建策略（单例、瞬时、原型等），控制依赖的生命周期。

## 基础使用流程

### 1. 注册可注入的组件（被依赖方）

使用 `@Component` 装饰器将类注册到 IoC 容器，使其可被注入：

```typescript
import { Component } from './core/ioc';

// 注册到默认模块，别名为 "userService"（类名首字母小写）
@Component
class UserService {
  getUserInfo(id: number) {
    return { id, name: '张三' };
  }
}

// 自定义模块和别名
@Component({ module: 'api', alias: 'productApi' })
class ProductService {
  getProduct(id: number) {
    return { id, name: '商品A' };
  }
}
```

### 2. 注入依赖（依赖方）

使用 `@Inject` 装饰器在类中声明依赖，容器会自动查找并注入对应的实例：

```typescript
import { Component, Inject } from './core/ioc';

@Component
class UserController {
  // 方式1：通过别名注入（默认模块）
  @Inject('userService')
  private userService: UserService;

  // 方式2：通过模块+别名注入
  @Inject('api.productApi')
  private productService: ProductService;

  // 方式3：通过类直接注入（推荐，类型安全）
  @Inject({ ctor: UserService })
  private userService2: UserService;

  async getUserData(userId: number) {
    const user = await this.userService.getUserInfo(userId);
    const product = await this.productService.getProduct(100);
    return { user, product };
  }
}
```

## 注入配置详解

`@Inject` 支持多种配置方式，满足不同场景的依赖查找需求：

### 1. 字符串表达式注入

格式：`[模块名.]别名`（模块名可选，默认模块为 `__default__`）

```typescript
// 注入默认模块的 "userService"
@Inject('userService')
private userService: UserService;

// 注入 "api" 模块的 "productApi"
@Inject('api.productApi')
private productService: ProductService;
```

### 2. 配置对象注入

通过对象指定更详细的查找条件：

```typescript
// 通过类查找（最常用，类型安全）
@Inject({ ctor: UserService })
private userService: UserService;

// 通过模块+别名查找
@Inject({ module: 'api', alias: 'productApi' })
private productService: ProductService;

// 指定实例作用域（默认 SINGLETON）
@Inject({
  ctor: UserService,
  scope: 'TRANSIENT' // 每次注入创建新实例
})
private transientUserService: UserService;
```

### 3. 构造函数直接注入

直接传入类作为参数（等价于 `{ ctor: 类 }`）：

```typescript
@Inject(UserService)
private userService: UserService;
```

## 实例作用域（Scope）

通过 `scope` 配置控制依赖实例的创建策略，默认值为 `SINGLETON`：

| 作用域         | 说明                             | 适用场景                 |
| -------------- | -------------------------------- | ------------------------ |
| `SINGLETON`    | 单例模式，全局唯一实例           | 工具类、配置服务         |
| `TRANSIENT`    | 瞬时模式，每次注入创建新实例     | 有状态的对象、请求上下文 |
| `PROTOTYPE`    | 原型模式，基于原实例创建新对象   | 需要继承原实例状态的场景 |
| `SHALLOWCLONE` | 浅克隆模式，复制原实例的表层属性 | 简单对象的快速复制       |
| `DEEPCLONE`    | 深克隆模式，完全复制原实例       | 复杂对象的独立副本       |

```typescript
// 瞬时模式：每次调用都会创建新实例
@Inject({ ctor: Logger, scope: 'TRANSIENT' })
private logger: Logger;
```

## 依赖查找规则

1. **精确匹配**：优先通过 `module + alias` 或 `ctor`（构造函数）精确查找。
2. **类型推断**：若未指定别名或构造函数，通过属性声明的类型（`design:type` 元数据）自动推断。
3. **备选实例**：当主实例查找失败时，可通过 `backups` 配置指定备选实例：

```typescript
@Inject({
  ctor: UserService,
  backups: [
    MockUserService, // 备选类（会自动实例化）
    { getUserInfo: () => ({ id: 0, name: '默认用户' }) } // 备选对象
  ]
})
private userService: UserService;
```

## 注入原理

1. **注册阶段**：`@Component` 装饰器通过 `InstanceFactory.registerInstance()` 将类信息存入容器。
2. **注入阶段**：
   - `@Inject` 装饰器解析配置，生成查找条件。
   - 调用 `InstanceFactory.getInstance()` 从容器中查找匹配的实例。
   - 根据 `scope` 策略创建或复用实例，并赋值给目标属性。
3. **元数据支持**：通过 `reflect-metadata` 提取属性类型信息（`design:type`），实现类型驱动的自动注入。

## 注意事项

1. **循环依赖**：避免 A 依赖 B 且 B 依赖 A 的循环依赖，容器会抛出实例查找异常。
2. **注册顺序**：被依赖的类必须先注册（建议通过 `@Component` 装饰器自动注册）。
3. **类型安全**：推荐使用 `ctor` 配置或类直接注入，利用 TypeScript 类型检查避免注入错误。
4. **测试友好**：通过依赖注入可轻松替换真实服务为 mock 服务，简化单元测试。

通过依赖注入机制，axios-plus 实现了组件间的低耦合，提高了代码的可维护性和可测试性，尤其适合大型项目中服务层与业务层的解耦。
