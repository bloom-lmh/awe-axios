# 依赖注入（Dependency Injection）

## 核心概念

在 `axios-plus` 中，依赖注入（`DI`）通过 `@Inject` 装饰器与 `IoC`（控制反转）容器实现，用于解耦组件间的依赖关系，自动管理实例的创建和注入过程。以下是详细实现方式和使用说明：

## 基本使用

`@Inject` 支持多种配置方式，满足不同场景的依赖查找需求：

### 字符串表达式注入

格式：`[模块名.]别名`（模块名可选，默认模块为 `__default__`）

```typescript
// 注入默认模块的 "userService"
@Inject('userService')
private userService: UserService;

// 注入 "api" 模块的 "productApi"
@Inject('api.productApi')
private productService: ProductService;
```

### 配置对象注入

当然你也可以通过配置对象来实现注入查找，配置对象结构为：

```ts
type GetInstanceConfig = {
  /**
   * 模块名
   */
  module?: string | symbol;
  /**
   * 别名
   */
  alias?: string;
  /**
   * 构造器
   */
  ctor?: DecoratorClass;
  /**
   * 创建实例模式
   */
  scope: InstanceScope | string;
  /**
   * 备份列表
   */
  backups?: InjectBackups;
};
```

如下示例：

```typescript
// 通过类查找（最常用，类型安全）
@Inject({ ctor: UserService })
private userService: UserService;

// 通过模块+别名查找
@Inject({ module: 'api', alias: 'productApi' })
private productService: ProductService;

```

::: warning 当同时配置了 `ctor` 和 `module + alias` 时
如果你同时配置了 `ctor` 和 `module + alias` ， `axios-plus`会只使用 `ctor` 来进行查找，并忽略 `module + alias` 。
:::

::: tip 关于`scope`和`backups`

`scope` 配置控制依赖实例的创建策略，默认值为 `SINGLETON`，`backups` 配置指定备选实例。后续会详细讲解
:::

### 构造函数直接注入

当然你也可以直接传入类作为参数（等价于 `{ ctor: 类 }`）：

```typescript
@Inject(UserService)
private userService: UserService;
```

## 依赖推断机制

当然你也可以什么都不配置，`axios-plus` 足够智能，它会自动推断依赖类型，如下所示：

```ts
@Inject()
private userService: UserService;
```

::: warning 但是这是有前提和风险的

1. `axios-plus`底层根据属性声明类型来进行推断，比如上面案例中的`userService: UserService`中声明的`UserService`类型，但类型推断并不总是准确的，比如 `typeof` 关键字，`any` 类型，`unknown` 类型等。如果你要使用这个功能你需要写明确切的类型注解来避免潜在的类型错误。
2. 面向对象语言中往往会采用多态，也就是说一个类会有很多子类，如果你注册了一个类的多个子类（然而父类没有注册），而使用时却使用的父类类型，那么`axios-plus`中会产生多个候选项（多个个同类子类实例），导致它并不能确定要为你注册哪个具体的子类。所以如果你要使用父类声明的属性，请确保有多个子类注册时，将这个父类也注册进去，这样就能产生一个最佳的候选人（这个父类）

:::
举个例子：

```typescript

```

## 实例作用域（Scope）

通过 `scope` 配置控制依赖实例的创建策略，默认值为 `SINGLETON`：

| 作用域         | 说明                             | 适用场景                 |
| -------------- | -------------------------------- | ------------------------ |
| `SINGLETON`    | 单例模式，全局唯一实例           | 工具类、配置服务         |
| `TRANSIENT`    | 瞬时模式，每次注入创建新实例     | 有状态的对象、请求上下文 |
| `PROTOTYPE`    | 原型模式，基于原实例创建新对象   | 需要继承原实例状态的场景 |
| `SHALLOWCLONE` | 浅克隆模式，复制原实例的表层属性 | 简单对象的快速复制       |
| `DEEPCLONE`    | 深克隆模式，完全复制原实例       | 复杂对象的独立副本       |

```typescript
// 瞬时模式：每次调用都会创建新实例
@Inject({ ctor: Logger, scope: 'TRANSIENT' })
private logger: Logger;
```

## 依赖查找规则

1. **精确匹配**：优先通过 `module + alias` 或 `ctor`（构造函数）精确查找。
2. **类型推断**：若未指定别名或构造函数，通过属性声明的类型（`design:type` 元数据）自动推断。
3. **备选实例**：当主实例查找失败时，可通过 `backups` 配置指定备选实例：

```typescript
@Inject({
  ctor: UserService,
  backups: [
    MockUserService, // 备选类（会自动实例化）
    { getUserInfo: () => ({ id: 0, name: '默认用户' }) } // 备选对象
  ]
})
private userService: UserService;
```

## 注入原理

1. **注册阶段**：`@Component` 装饰器通过 `InstanceFactory.registerInstance()` 将类信息存入容器。
2. **注入阶段**：
   - `@Inject` 装饰器解析配置，生成查找条件。
   - 调用 `InstanceFactory.getInstance()` 从容器中查找匹配的实例。
   - 根据 `scope` 策略创建或复用实例，并赋值给目标属性。
3. **元数据支持**：通过 `reflect-metadata` 提取属性类型信息（`design:type`），实现类型驱动的自动注入。

## 注意事项

1. **循环依赖**：避免 A 依赖 B 且 B 依赖 A 的循环依赖，容器会抛出实例查找异常。
2. **注册顺序**：被依赖的类必须先注册（建议通过 `@Component` 装饰器自动注册）。
3. **类型安全**：推荐使用 `ctor` 配置或类直接注入，利用 TypeScript 类型检查避免注入错误。
4. **测试友好**：通过依赖注入可轻松替换真实服务为 mock 服务，简化单元测试。

通过依赖注入机制，axios-plus 实现了组件间的低耦合，提高了代码的可维护性和可测试性，尤其适合大型项目中服务层与业务层的解耦。
