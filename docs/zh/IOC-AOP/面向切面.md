# 面向切面

## 基本概念

`axios-plus`还实现了面向切面编程（`AOP`）的功能，通过`@Before`、`@After`等装饰器，可以对请求前、请求后、请求错误等阶段进行拦截，并对请求进行处理。

## 切面类

使用`@Aspect`可以定义切面类。切面类中的方法可以在目标方法的不同执行阶段产生影响。定义切面类方式如下：

```typescript {1-2}
// 定义切面类
@Aspect()
class Logger {
  @Before('getUser*')
  log(ctx: AspectContext) {
    console.log('before getUser*');
  }
}
```

## 切点表达式

> `aop`的核心在于明确在什么方法、方法什么执行阶段进行切入。这个方法就是切入点（或者说叫做切入位置），切入点需要使用切入点表达式来表示。

切入点表达式其实就是就是指定切入位置的字符串，通过字符串的方式指定切入位置。其语法为:`[模块名].[类名].(方法名)`，并且这些字符串都支持用`*`作为通配符表示任意字符。比如：

1. `getUser*`：表示所有以`getUser`开头的方法
2. `UserApi.getUser*`：表示`UserApi`类中所有以`getUser`开头的方法
3. `UserApi.getUserById`：表示`UserApi`类中`getUserById`方法
4. `UserApi.*`：表示`UserApi`类中所有的方法
5. `user.UserApi.getUserById`：表示`user`模块中`UserApi`类中`getUserById`方法
6. `*`：表示所有的方法

::: tip 缓存优化
`axios-plus`对使用过的切点表达式进行函数记忆缓存，避免重复执行，提高性能。
:::

## 切入时机

切入时机指的是在什么阶段进行切入，比如：

### @Before

`@Before`装饰器用于在方法调用前进行拦截

```ts {3-6}
@Aspect(1)
class Logger {
  @Before('getUser*')
  log(ctx: AspectContext) {
    // 调用方法前打印before getUser*
    console.log('before getUser*');
  }
}
const userApi = new UserApi();
const { data } = await userApi.getUserPages()();
console.log(data);
```

### @After

`@After`装饰器用于在方法调用后进行拦截

```ts {3-6}
@Aspect(1)
class Logger {
  @After('getUser*')
  logAfter(ctx: AspectContext) {
    console.log('after getUser*');
  }
}
const userApi = new UserApi();
const { data } = await userApi.getUserPages()();
console.log(data);
```

### @Around

`@Around`装饰器用于在方法调用前后进行拦截

```ts {3-9}
@Aspect(1)
class Logger {
  @Around('getUser*')
  logAround(ctx: AspectContext, adviceChain: AdviceChain) {
    console.log('around before getUser*');
    const result = adviceChain.proceed(ctx);
    console.log('arount after getUser*');
    return result;
  }
}
const userApi = new UserApi();
const { data } = await userApi.getUserPages()();
console.log(data);
```

::: warning 注意

1. `@Around`装饰器必须要有返回值，否则会报错。
2. 你必须要调用`adviceChain.proceed(ctx)`方法来手动推进执行链的执行，否则不会执行目标方法。

:::

### @AfterReturning

`@AfterReturning`装饰器用于在方法调用成功后进行拦截，它可以获取到方法的返回值，并进行处理。

```ts
@Aspect(1)
class Logger {
  @AfterReturning('getUser*')
  logAfterReturning(ctx: AspectContext, result: any) {
    console.log(result);
    console.log('afterReturning getUser*');
  }
}
const userApi = new UserApi();
const { data } = await userApi.getUserPages()();
console.log(data);
```

### @AfterThrowing

`@AfterThrowing`装饰器用于在方法调用失败后进行拦截，它可以获取到方法的错误信息，并进行处理。

```ts
@Aspect(1)
class Logger {
  @AfterThrowing('getUser*')
  logAfterThrowing(ctx: AspectContext, error: any) {
    console.log('出错了');
    console.log('afterThrowing getUser*');
  }
}
const userApi = new UserApi();
const { data } = await userApi.getUserPages()();
console.log(data);
```

## 切点上下对象

### 基本概念

切点上下对象（`AspectContext`）是`axios-plus`中用于保存切点信息的对象，也就是在上面的方法中第一个参数`ctx`。它包含了如下信息：

```ts
export class AspectContext {
  /**
   * 原方法
   */
  method: Function;
  /**
   * 原方法this
   */
  target: any;
  /**
   * 原方法参数
   */
  args: any[];

  /**
   * axios配置
   */
  axiosConfig?: HttpRequestConfig;
}
```

所以，你可以通过`ctx.method`、`ctx.target`、`ctx.args`获取到原方法、原方法 `this`、原方法参以及`axios`配置数等。所以你可以利用这些信息更加精确的实现拦截功能。

### 精确拦截 axios 请求和响应

## 可复用的切入表达式

## 执行顺序

### 切点执行顺序

```ts
@Component()
@HttpApi('http://localhost:3000/api/users')
class UserApi {
  @Get({
    url: '/pages',
    mock: () => {
      return HttpResponse.json({
        data: 'hello world',
      });
    },
  })
  getUserPages(): any {}
  getUsers(): any {}
}
@Aspect(1)
class Logger {
  @Before('getUser*')
  log(ctx: AspectContext) {
    console.log('before getUser*');
  }
  @After('getUser*')
  logAfter(ctx: AspectContext) {
    console.log('after getUser*');
  }
  @Around('getUser*')
  logAround(ctx: AspectContext, adviceChain: AdviceChain) {
    console.log('around before getUser*');
    const result = adviceChain.proceed(ctx);
    console.log('arount after getUser*');
    return result;
  }
  @AfterReturning('getUser*')
  logAfterReturning(ctx: AspectContext, result: any) {
    console.log(result);
    console.log('afterReturning getUser*');
  }
  @AfterThrowing('getUser*')
  logAfterThrowing(ctx: AspectContext, error: any) {
    console.log('出错了');
    console.log('afterThrowing getUser*');
  }
}
const userApi = new UserApi();
const { data } = await userApi.getUserPages()();
console.log(data);
```

### 切面类的执行顺序

```

```
