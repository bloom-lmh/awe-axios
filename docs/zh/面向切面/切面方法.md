在 axios-plus 中，AOP 相关装饰器是实现面向切面编程的核心，包括切面类装饰器 `@Aspect` 和五种通知装饰器（`@Before`、`@After`、`@Around`、`@AfterReturning`、`@AfterThrowing`）。以下是各装饰器的详细说明：

### 1. `@Aspect`：切面类装饰器

**作用**：声明一个类为切面类，用于集中定义横切逻辑（通知方法），并指定切面的执行优先级。

#### 用法

```typescript
import { Aspect } from 'axios-plus';

// 优先级为 1（数字越小，优先级越高，越先执行前置逻辑，越后执行后置逻辑）
@Aspect(1)
class HttpLogAspect {
  // 通知方法（@Before、@After等）定义在这里
}
```

#### 核心特性

- **优先级控制**：通过参数 `config` 指定优先级（默认值为 5），多个切面执行时，优先级高（数字小）的切面先执行前置通知，后执行后置通知（类似栈结构）。
- **冲突限制**：不能与 `@Component`、`@HttpApi` 等类装饰器同时使用（避免职责混淆）。
- **自动注册**：被 `@Aspect` 装饰的类会自动被框架识别，无需额外注册即可生效。

### 2. `@Before`：前置通知装饰器

**作用**：在目标方法执行**之前**触发，用于请求参数校验、日志记录、权限预处理等场景。

#### 用法

```typescript
import { Aspect, Before, AspectContext } from 'axios-plus';

@Aspect(1)
class RequestAspect {
  // 匹配所有模块中以 "Api" 结尾的类的 get 方法
  @Before({ ctor: /Api$/, method: /^get/ })
  logRequestParams(context: AspectContext) {
    console.log('请求参数:', context.args); // 打印目标方法入参
    // 可修改参数：context.args = [...context.args, { timestamp: Date.now() }];
  }
}
```

#### 切入点配置

支持两种方式指定目标方法：

- **配置对象**：通过 `module`（模块名正则）、`ctor`（类名正则）、`method`（方法名正则）精细匹配。
  ```typescript
  @Before({
    module: /service/, // 匹配模块名含 "service" 的类
    ctor: UserApi, // 精确匹配 UserApi 类
    method: 'getUser' // 精确匹配 getUser 方法
  })
  ```
- **字符串表达式**：格式为 `模块.类.方法`，支持 `*` 通配符（`*` 匹配任意字符）。
  ```typescript
  @Before('*.UserApi.get*') // 匹配所有模块中 UserApi 类的 get 开头方法
  ```

#### 上下文（`AspectContext`）

通知方法的参数为 `AspectContext` 对象，包含：

- `method`：目标方法本身。
- `target`：目标方法所属的类实例（`this` 指向）。
- `args`：目标方法的入参数组（可修改）。
- `axiosConfig`：若目标是 HTTP 方法，包含 axios 请求配置（可修改请求头、URL 等）。

### 3. `@After`：后置通知装饰器

**作用**：在目标方法执行**之后**触发（无论成功或失败），用于清理资源、记录请求完成状态等。

#### 用法

```typescript
import { Aspect, After, AspectContext } from 'axios-plus';

@Aspect(1)
class RequestAspect {
  // 匹配所有 HTTP POST 方法
  @After({ method: /^post/ })
  logRequestFinish(context: AspectContext) {
    console.log('请求结束，方法名:', context.method.name);
  }
}
```

#### 特性

- **执行时机**：在目标方法执行后触发，无论是否抛出异常。
- **切入点配置**：与 `@Before` 一致，支持配置对象和字符串表达式。
- **上下文访问**：同 `@Before`，可获取目标方法信息，但修改 `args` 对已执行的目标方法无影响。

### 4. `@Around`：环绕通知装饰器

**作用**：包裹目标方法的执行流程，可在目标方法执行前后插入逻辑，甚至控制是否执行目标方法（最灵活的通知类型）。

#### 用法

```typescript
import { Aspect, Around, AspectContext, AdviceChain } from 'axios-plus';

@Aspect(1)
class PerformanceAspect {
  // 匹配所有 fetch 开头的方法
  @Around({ method: /^fetch/ })
  async trackPerformance(context: AspectContext, chain: AdviceChain) {
    const start = Date.now();
    try {
      // 执行后续通知和目标方法（必须调用，否则流程中断）
      const result = await chain.proceed(context);
      console.log('耗时:', Date.now() - start, 'ms');
      return result; // 返回目标方法结果
    } catch (error) {
      console.error('请求异常，耗时:', Date.now() - start, 'ms');
      throw error; // 继续抛出异常，让异常通知处理
    }
  }
}
```

#### 核心特性

- **参数**：除 `AspectContext` 外，还需接收 `AdviceChain`（通知链），通过 `chain.proceed(context)` 触发后续流程。
- **执行时机**：在 `@Before` 之前执行前部逻辑，在 `@After` 之后执行后部逻辑（包裹整个流程）。
- **控制权**：可中断目标方法执行（不调用 `chain.proceed`），或修改返回结果、捕获异常。

### 5. `@AfterReturning`：返回通知装饰器

**作用**：在目标方法**成功执行并返回结果后**触发，用于处理返回值、日志记录等。

#### 用法

```typescript
import { Aspect, AfterReturning, AspectContext } from 'axios-plus';

@Aspect(1)
class ResponseAspect {
  // 匹配 UserApi 类的所有方法
  @AfterReturning({ ctor: UserApi })
  handleSuccessResult(context: AspectContext, result: any) {
    console.log('请求成功，结果:', result);
    // 可修改返回值：return { ...result, extra: '附加信息' };
  }
}
```

#### 特性

- **参数**：除 `AspectContext` 外，还接收目标方法的返回值 `result`（可修改并返回新结果）。
- **执行时机**：仅在目标方法无异常时执行，晚于 `@After` 通知。
- **切入点配置**：与其他通知一致，支持灵活匹配目标方法。

### 6. `@AfterThrowing`：异常通知装饰器

**作用**：在目标方法**抛出异常时**触发，用于异常捕获、错误日志记录、告警等。

#### 用法

```typescript
import { Aspect, AfterThrowing, AspectContext } from 'axios-plus';

@Aspect(1)
class ErrorAspect {
  // 匹配所有模块中含 "api" 的类
  @AfterThrowing({ module: /api/ })
  handleRequestError(context: AspectContext, error: Error) {
    console.error('请求失败:', error.message);
    // 可自定义异常：throw new Error('包装后的异常信息');
  }
}
```

#### 特性

- **参数**：除 `AspectContext` 外，还接收目标方法抛出的 `error` 对象（可捕获并重新抛出）。
- **执行时机**：仅在目标方法抛出异常时执行，与 `@AfterReturning` 互斥。
- **异常传递**：若在通知中重新抛出异常，后续异常处理逻辑（如更外层的 `@AfterThrowing`）会继续捕获。

### 通知执行顺序总结

当多个通知同时匹配同一目标方法时，执行顺序如下（假设 `order1 < order2`，即切面 1 优先级高于切面 2）：

```
order1 @Around 前部 →
order1 @Before →
order2 @Around 前部 →
order2 @Before →
【目标方法执行】→
order2 @After →
order2 @AfterReturning（若成功）/ @AfterThrowing（若失败）→
order2 @Around 后部 →
order1 @After →
order1 @AfterReturning（若成功）/ @AfterThrowing（若失败）→
order1 @Around 后部
```

### 关键注意事项

1. **切入点性能**：避免使用过于宽泛的匹配（如 `.*` 匹配所有），可能导致不必要的性能开销。
2. **异步支持**：所有通知方法支持 `async/await`，框架会等待异步操作完成后再继续执行。
3. **环绕通知必须调用 `chain.proceed`**：否则会中断通知链和目标方法的执行。
4. **装饰器冲突**：同一方法上不能同时使用多个同类型通知装饰器（如多个 `@Before`），框架会抛出冲突错误。

通过这些装饰器，axios-plus 实现了业务逻辑与横切逻辑（日志、监控、异常处理等）的解耦，大幅提升代码可维护性。
