# 子项装饰器

## 介绍

实际上为了让配置更加精简，`awe-axios`也提供了关于 `mock` 的子项装饰器，你只需要使用`@Mock`即可配置 `mock` 相关的配置项，这个装饰器接受两个参数：

1. 第一个参数为`handlers`它可以是一个处理器函数也可以是一个对象

```ts
@Mock(async ({ request, params }) => {
  return HttpResponse.json({
    data: [
      { id: 1, name: 'Alice' },
      { id: 2, name: 'Bob' },
    ],
  });
})
// 或
@Mock({
  default: async ({ request, params }) => {
    return HttpResponse.json({
      data: [
        { id: 1, name: 'Alice' },
        { id: 2, name: 'Bob' },
      ],
    });
  },
  success: async ({ request, params }) => {
    return HttpResponse.json({
      data: [
        { id: 1, name: 'Alice' },
        { id: 2, name: 'Bob' },
      ],
    });
  },
})
```

2. 第二个参数为 `mock` 的配置项

```ts
export type MockConfig = {
  /**
   * 是否开启mock
   * @description 开启后，若条件满足则所有请求都会走mock接口
   */
  on?: boolean;
  /**
   * 走mock的条件
   * @description 开启mock后，为了不改变原代码，我们可以设置走真实接口的条件
   */
  condition?: () => boolean;
  /**
   * 运作次数
   * @description mock次数，当接口被mock对应次数后不再访问mock接口
   */
  count?: number;

  /**
   * 取消mock的信号量
   * @description 区别于condition，这个可以动态的取消mock
   */
  signal?: Signal;
};
```

## 优先级与合并策略

`@Mock`中定义的`handlers`会和`@Get`等`http`装饰器的`handlers`进行合并，优先级低于`@Get`等装饰器的`handlers`，也就是说，如果`@Mock`中定义了与`@Get`相同的`handlers`，则`@Mock`的装饰器的`handlers`不会生效。
