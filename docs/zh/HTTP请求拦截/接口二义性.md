# 接口二义性

axios-plus 底层采用 msw 来实现 http 请求的拦截，msw 是真实从网络层进行拦截的 mock 工具库。axios-plus 在此基础之上，进行了二次封装，并直接采用真实接口的路径作为 mock 的路径，这样就简化了接口的配置，让接口即是真实接口又是 mock 接口

## mock 配置

### 基础配置方式

mock 配置支持多种灵活的定义形式，可通过 `@HttpApi` 类装饰器或请求方法装饰器（如 `@Get`、`@Post`）进行配置，优先级遵循「方法配置 > 类配置」。

#### 1. 简单函数配置

直接传入一个响应处理函数，默认匹配 `default` 场景：

```typescript
@Get({
  url: '/users',
  mock: () => HttpResponse.json({ list: [] })
})
getUserList() {}
```

#### 2. 多场景配置

通过 `handlers` 定义多组响应处理逻辑，支持按场景名称调用：

```typescript
@Post({
  url: '/login',
  mock: {
    handlers: {
      success: () => HttpResponse.json({ code: 200, token: 'xxx' }),
      error: () => HttpResponse.json({ code: 401, message: '密码错误' }, { status: 401 })
    },
    count: 3, // 仅生效3次
    signal: abortSignal // 可通过信号量动态取消
  }
})
login() {}
```

#### 3. 类级别全局配置

在 `@HttpApi` 中配置全局 mock 规则，统一管理整个 API 类的 mock 行为：

```typescript
@HttpApi({
  baseURL: '/api',
  mock: {
    on: process.env.NODE_ENV === 'development', // 仅开发环境启用
    condition: () => !window.__REAL_API__, // 支持动态条件
  },
})
class UserApi {
  // 方法会继承类的mock配置
  @Get({ url: '/profile' })
  getProfile() {}
}
```

### 核心配置项说明

| 配置项      | 类型                                  | 说明                                         |
| ----------- | ------------------------------------- | -------------------------------------------- |
| `on`        | `boolean`                             | 是否启用 mock，默认为 `true`                 |
| `handlers`  | `MockHandlersObject` \| `MockHandler` | 响应处理器，支持单函数或多场景对象           |
| `condition` | `() => boolean`                       | 动态条件函数，返回 `true` 时启用 mock        |
| `count`     | `number`                              | 限制 mock 生效次数，超过后自动切换到真实接口 |
| `signal`    | `Signal`                              | 信号量对象，通过 `abort()` 可立即终止 mock   |

### 调用与切换

#### 1. 默认调用

不指定场景时，自动使用 `default` 处理器：

```typescript
const api = new UserApi();
// 触发 mock.handlers.default
const res = await api.getUserList();
```

#### 2. 场景切换

通过传入场景名称指定使用对应处理器：

```typescript
// 触发 mock.handlers.success
const successRes = await api.login()('success');

// 触发 mock.handlers.error
const errorRes = await api.login()('error');
```

#### 3. 临时禁用

通过信号量或条件函数动态关闭 mock：

```typescript
// 创建信号量
const controller = new AbortController();

// 配置signal
@Post({
  url: '/submit',
  mock: {
    signal: controller.signal,
    handlers: { default: () => HttpResponse.json({}) }
  }
})
submit() {}

// 调用时临时关闭mock
controller.abort();
const realRes = await api.submit();
```

### 路径处理与接口映射

axios-plus 会自动处理路径拼接逻辑，确保 mock 路径与真实接口路径完全一致：

1. 若配置 `baseURL` + `url`，则 mock 路径自动拼接为 `baseURL/url`
2. 若 `url` 为绝对路径（如 `https://api.example.com/users`），则直接使用该路径作为 mock 拦截路径
3. 支持路径参数（如 `/users/:id`），msw 会自动匹配带参数的请求

这种设计避免了传统 mock 工具中「真实路径与 mock 路径需分别配置」的冗余问题，实现了接口的「一处定义，双重用途」。

### 全局管理

通过 `MockAPI` 工具类可全局控制 mock 状态：

```typescript
import { MockAPI } from 'axios-plus';

// 开启所有mock
MockAPI.on();

// 关闭所有mock（真实关闭，清除拦截器）
MockAPI.off(true);

// 重置所有处理器
MockAPI.resetHandlers();

// 检查是否存在指定接口的mock处理器
const hasHandler = MockAPI.hasHandler('/users', 'get');
```

### 注意事项

1. **优先级顺序**：信号量 `signal` > 次数限制 `count` > 条件函数 `condition` > 全局开关 `on`
2. **环境隔离**：建议通过 `process.env.NODE_ENV` 控制生产环境自动关闭 mock
3. **类型安全**：所有响应处理器均支持 TypeScript 类型推导，确保 mock 数据结构与真实响应一致
4. **冲突处理**：同一接口的重复 mock 配置会自动合并，后注册的处理器会覆盖同名场景
5. **网络行为模拟**：支持通过 `msw` 的 `HttpResponse` 模拟状态码、响应头、延迟等真实网络特性

通过上述配置，axios-plus 实现了 mock 与真实接口的无缝切换，既保留了 msw 网络层拦截的真实性，又简化了配置复杂度，解决了传统方案中接口定义二义性的问题。
