# 子项装饰器

## 基本介绍

`awe-axios`定义了一些子项装饰器，这些装饰器就像是语法糖一样，可以让用户更加方便的去进行配置。我们来看一个案例：

```ts {7-16}
@HttpApi({
  refAxios: request,
})
class UserApi {
  @Get({
    url: '/pages',
    transformResponse: [
      data => {
        // handle1
        return data;
      },
      data => {
        // handle2
        return data;
      },
    ],
  })
  getUserPages(): any {}
}
```

可以看到我们所有的`http`请求配置项都配置再`@Get`中，这会导致配置十分臃肿，于是`awe-axios`定义了一些子项装饰器，用来让配置结构更加清晰，比如下面我们使用了`@TransformResponse`将响应数据处理器从`@Get`中分离：

```ts {11-22}
const request = axiosPlus.create({
  baseURL: 'http://localhost:3000/users/',
});
@HttpApi({
  refAxios: request,
})
class UserApi {
  @Get({
    url: '/pages',
  })
  @TransformResponse([
    data => {
      return JSON.parse(data).data;
    },
    data => {
      data = data.map((user: any) => {
        user['age'] = 12;
        return user;
      });
      return data;
    },
  ])
  getUserPages(@QueryParam('page') page: number, @QueryParam('size') size: number): any {}
}
const { data } = await new UserApi().getUserPages(1, 3);
console.log(data);
```

实际上`awe-axios`还有其它的子项装饰器，比如：`@RefAxios`，`@AxiosRef`等

## @RefAxios

这个装饰器是一个类子装饰器，用于设置该类所有`http`接口所引用的`axios`实例，它接受一个`axios`实例对象作为配置项，如下所示：

```ts {12-13}
const request = axiosPlus.create({
  baseURL: 'http://localhost:3000/users/',
});
@HttpApi()
@RefAxios(request)
class UserApi {
  @Get({
    url: '/pages',
  })
  getUserPages(@QueryParam('page') page: number, @QueryParam('size') size: number): any {}
}
// 最终发送接口为http://localhost:3000/users/pages?size=3&page=1
const { data } = await new UserApi().getUserPages(1, 3);
console.log(data);
```

::: tip 配置优先级
子装饰器的配置小于直接在父类装饰器中直接配置，也就是说：

```ts {8,10}
const request1 = axiosPlus.create({
  baseURL: 'http://localhost:3000/users/',
});
const request2 = axiosPlus.create({
  baseURL: 'http://localhost:3000/orders/',
});
@HttpApi({
  refAxios: request1,
})
@RefAxios(request2)
class UserApi {
  @Get({
    url: '/pages',
  })
  getUserPages(@QueryParam('page') page: number, @QueryParam('size') size: number): any {}
}
// 最终发送接口为http://localhost:3000/users/pages?size=3&page=1
const { data } = await new UserApi().getUserPages(1, 3);
console.log(data);
```

最终发送的接口为`http://localhost:3000/users/pages?size=3&page=1`，而不是`http://localhost:3000/orders/pages?size=3&page=1`
:::

::: warning 注意
同时要注意，`@RefAxios`需要依托`@HttpApi`装饰器，也就是说`@HttpApi`不可缺少，否则会报错。
:::

## @AxiosRef

这个装饰器是一个方法装饰器，用于设置该方法所引用的`axios`实例，它接受一个`axios`实例对象作为配置项，如下所示：

```ts {8}
const request = axiosPlus.create({
  baseURL: 'http://localhost:3000/users/',
});
class UserApi {
  @Get({
    url: '/pages',
  })
  @AxiosRef(request)
  getUserPages(@QueryParam('page') page: number, @QueryParam('size') size: number): any {}
}
// 最终发送接口为http://localhost:3000/users/pages?size=3&page=1
const { data } = await new UserApi().getUserPages(1, 3);
console.log(data);
```

可以看到使用了`@AxiosRef`甚至都不再需要使用`@HttpApi`了，因为`@AxiosRef`会直接为`getUserPages`绑定一个`axios`实例。

同时，`@AxiosRef`也可以在父类装饰器中配置，子项装饰器的配置优先级仍然小于父类装饰器的配置，如下所示：

```ts {11,13}
const request1 = axiosPlus.create({
  baseURL: 'http://localhost:3000/users/',
});
const request2 = axiosPlus.create({
  baseURL: 'http://localhost:3000/orders/',
});

class UserApi {
  @Get({
    url: '/pages',
    refAxios: request1,
  })
  @AxiosRef(request2)
  getUserPages(@QueryParam('page') page: number, @QueryParam('size') size: number): any {}
}
// 最终发送接口为http://localhost:3000/orders/pages?size=3&page=1
const { data } = await new UserApi().getUserPages(1, 3);
console.log(data);
```

::: tip 总结配置优先级
`@Get`中配置> `@AxiosRef`装饰器配置> `@HttpApi`装饰器配置> `@RefAxios`装饰器配置
:::

## @TransformResponse

这个装饰器是一个方法装饰器，用于设置响应数据处理器，与`axios`中的`transformResponse`一致，它接受一个处理函数或数组，数组中的每一项都是一个函数，函数的返回值将下一个函数的输入，最后一个函数的返回将作为最终响应数据，如下所示：

```ts {8-21}
const request = axiosPlus.create({
  baseURL: 'http://localhost:3000/users/',
});
class UserApi {
  @Get({
    url: '/pages',
  })
  @TransformResponse([
    // 1. 直接获取data数
    data => {
      return JSON.parse(data).data;
    },
    // 2. 增加age属性
    data => {
      data = data.map((user: any) => {
        user['age'] = 12;
        return user;
      });
      return data;
    },
  ])
  getUserPages(@QueryParam('page') page: number, @QueryParam('size') size: number): any {}
}
```

::: tip 执行顺序以及合并策略

1. `@TransformResponse`中的每个函数是自上而下执行的
2. 如果`@Get`中配置了`transformResponse`，则会与`@TransformResponse`合并，且`@Get`中的函数会在`@TransformResponse`中的函数之前执行`

:::

## @TransformRequest

这个装饰器是一个方法装饰器，用于设置请求数据处理器，与`axios`中的`transformRequest`一致，它接受一个处理函数或数组，数组中的每一项都是一个函数，函数的返回值将作为下一个函数的输入，最后返回作为请求数据，如下所示：

```ts
@HttpApi('http://localhost:3000/users/')
class UserApi {
  @Post({
    url: '/',
  })
  @TransformRequest([
    // 为user添加属性sex
    data => {
      data.sex = '男';
      return data;
    },
    data => {
      data.email = '1111@11.com';
      return JSON.stringify(data);
    },
  ])
  createUser(@BodyParam() user: { name: string; age: number }): any {}
}
const { data } = await new UserApi().createUser({ name: 'test', age: 18 });
console.log(data);
```

::: tip 执行顺序以及合并策略

1. `@TransformRequest`中的每个函数是自上而下执行的
2. 如果`@Post`中配置了`transformRequest`，则会与`@TransformRequest`合并，且`@Post`中的函数会在`@TransformRequest`中的函数之前执行`

:::

## 更多子项装饰器

目前只提供了这四种装饰器，后续会陆续增加更多的子项装饰器，欢迎大家提出宝贵意见。
