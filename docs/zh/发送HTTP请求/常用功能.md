# 常用功能详解

## 超时重传（Retry）

超时重传功能用于在请求失败时自动重试，提高接口调用的成功率，适用于网络不稳定的场景。

### 配置方式

支持多种配置格式：

```typescript
// 1. 仅指定重试次数
@Get({
  url: '/data',
  retry: 3 // 重试3次
})

// 2. 完整配置
@Get({
  url: '/data',
  retry: {
    count: 3,      // 重试次数
    delay: 1000,   // 基础延迟时间(ms)
    signal: abortSignal // 取消信号
  }
})

// 3. 数组形式 [次数, 延迟]
@Get({
  url: '/data',
  retry: [3, 1000]
})

// 4. 使用装饰器单独配置
@Get('/data')
@Retry({ count: 3, delay: 1000 })
getData() {}
```

### 实现原理

- 采用指数退避策略：第 n 次重试的延迟时间为 `delay * 2^(n-1)`
- 首次重试无延迟，从第二次开始应用延迟策略
- 可通过 `signal` 信号量手动取消重试机制

### 适用场景

- 网络请求偶尔失败的接口
- 非实时性要求的接口
- 对成功率要求较高的场景

## 防抖（Debounce）

防抖功能用于限制短时间内多次触发的请求，只执行最后一次请求，适用于频繁触发的场景。

### 配置方式

```typescript
// 1. 仅指定延迟时间(ms)
@Get({
  url: '/search',
  debounce: 300 // 300ms内多次调用只执行最后一次
})

// 2. 完整配置
@Get({
  url: '/search',
  debounce: {
    delay: 300,      // 延迟时间
    immediate: false, // 是否立即执行第一次请求
    signal: abortSignal // 取消信号
  }
})

// 3. 使用装饰器单独配置
@Get('/search')
@Debounce(300)
search() {}
```

### 实现原理

- 维护一个定时器，每次触发时重置定时器
- 延迟时间结束后执行最后一次请求
- `immediate: true` 时会立即执行第一次请求，后续触发才进入防抖逻辑

### 适用场景

- 搜索框输入联想
- 窗口大小调整触发的请求
- 频繁点击按钮的场景

## 节流（Throttle）

节流功能用于限制请求的执行频率，确保在指定时间间隔内只执行一次，适用于持续触发的场景。

### 配置方式

```typescript
// 1. 仅指定间隔时间(ms)
@Get({
  url: '/scroll',
  throttle: 1000 // 1秒内最多执行一次
})

// 2. 完整配置
@Get({
  url: '/scroll',
  throttle: {
    interval: 1000, // 间隔时间
    signal: abortSignal // 取消信号
  }
})

// 3. 使用装饰器单独配置
@Get('/scroll')
@Throttle(1000)
loadMore() {}
```

### 实现原理

- 记录上次执行时间，每次触发时检查时间间隔
- 间隔时间内的触发会排队等待，间隔结束后执行最后一次触发
- 首次触发会立即执行，无需等待

### 适用场景

- 滚动加载更多数据
- 拖拽操作触发的请求
- 实时数据刷新（如仪表盘）

## 执行顺序与冲突说明

### 执行顺序

当同时配置多种功能时，执行顺序固定为：

```
防抖(Debounce) → 节流(Throttle) → 超时重传(Retry) → 实际请求
```

这是由内部实现逻辑决定的，从用户触发到实际请求会依次经过这些策略处理。

### 不兼容组合

1. **防抖与节流不能同时使用**

   - 两者都是流量控制策略，同时使用会导致逻辑冲突
   - 框架会检测这种冲突并抛出警告
   - 建议根据具体场景选择更适合的一种

2. **注意事项**
   - 重传功能可以与防抖/节流同时使用，因为它作用于请求失败后的重试逻辑
   - 当使用自定义策略（`customDebounce`/`customThrottle`/`customRetry`）时，仍需遵守上述冲突规则
   - 信号量（`signal`）可以同时控制多种策略的取消

### 推荐组合

- 搜索场景：`防抖 + 重传`
- 滚动加载：`节流 + 重传`
- 普通接口：`仅重传`（大多数场景）

这些组合既能保证用户体验，又能提高请求成功率，同时避免策略冲突。
