# 常用功能详解

`axios-plus`封装了一些常用的功能，包括：

- 请求重发（`Retry`）
- 防抖（`Debounce`）
- 节流（`Throttle`）

本文将详细介绍这些功能的配置及实现原理，并介绍它们的适用场景。

## 请求重发（Retry）

### 基本使用

请求重发功能用于在请求失败时自动重试发起请求，提高接口调用的成功率，适用于网络不稳定的场景。基本使用如下：

```js {3}
@Get({
  url: '/data',
  retry: true
})
```

::: tip 默认值
当你指定`retry`为 `ture` 时，`axios-plus`会采用默认的请求重复时间和重试次数，具体如下：

- 重试次数：`3` 次
- 基础延迟时间：1000ms

:::

### 多种配置方式

上面的配置方式是最简单的，以默认的重试次数和基础延迟时间提供，但这并不一定能满足你的需求，所以`axios-plus`支持多种配置方式，你可以通过以下方式进行配置来满足你的项目需求：
::: code-group

```js [仅指定重试次数] {3}
@Get({
  url: '/data',
  retry: 3 // 重试3次
})
```

```js [完整配置] {3-7}
@Get({
  url: '/data',
  retry: {
    count: 3,      // 重试次数
    delay: 1000,   // 基础延迟时间(ms)
    signal: abortSignal // 取消信号
  }
})
```

```js [数组形式 [次数, 延迟]] {3}
@Get({
  url: '/data',
  retry: [3, 1000]
})

```

:::

### 卸载请求重发功能

`axios-plus`借鉴了`axios`的信号量机制，让其可以在运行时通过 `signal` 信号量注销请求重发功能，示例如下：

```js{1-2,10-11,16-20}
// 请求重发控制器
const retrySignalCtr = new SignalController();
@HttpApi({
  baseURL: 'http://localhost:3000/users/',
})
class UserApi {
  @Get({
    url: '/retry/:id',
    retry: {
      // 请求重发信号量
      signal: retrySignalCtr.signal,
    },
  })
  getUserById(@PathParam('id') id: number): any {}
}
// 取消重传
retrySignalCtr.abort();
const userApi = new UserApi();
// 不再进行请求重发
const { data } = await userApi.getUserById(1);
console.log(data);
```

::: warning 与取消请求的区别
当你卸载了请求重发功能，并不会导致请求取消，而是后续的请求不会采用请求重发功能，就相当于是运行时取消了请求重发功能，但不会影响到已经发起的请求。如果你需要取消发起的请求，请使用原生`axios`的信号量机制:

```ts {2,9,16}
// 请求控制器
const requestCtr = new AbortController();
@HttpApi({
  baseURL: 'http://localhost:3000/users/',
})
class UserApi {
  @Get({
    url: '/retry/:id',
    signal: requestCtr.signal,
  })
  getUserById(@PathParam('id') id: number): any {}
}
const userApi = new UserApi();
setTimeout(() => {
  // 取消请求
  requestCtr.abort();
}, 100);
const { data } = await userApi.getUserById(1);
```

:::

### 自定义请求重发策略

`axios-plus`允许自定义请求重发策略，你可以通过 `customRetry` 配置项来实现，如下所示：

```ts
@HttpApi({
  baseURL: 'http://localhost:3000/users/',
})
class UserApi {
  @Get({
    url: '/retry/:id',
    retry: true,
    customRetry: useRetry,
  })
  getUserById(@PathParam('id') id: number): any {}
}
// 取消重传
const userApi = new UserApi();
// 不再进行请求重发
const { data } = await userApi.getUserById(1);
```

::: warning 注意
你仍然需要指定`retry`为 `配置项` 来开启请求重发功能，`axios-plus`会将`retry`配置项当作`config`传递给`customRetry`，否则自定义策略不会生效。
:::
对于自定义请求重发策略，你需要遵循`axios-plus`自定义的规范，否则不会生效，规范如下：

`retry`是一个高阶函数，它返回一个新的请求函数，并接受两个参数。

1. 是基本请求函数`requestFn`，这个函数的作用是发起`axios`请求，同时接受`axios-plus`请求配置项作为参数；
2. 是`retry`配置项，它定义重试次数、延迟时间、取消信号量等。如下所示：

::: code-group

```js [完整示例]
/**
 * 自定义重试策略
 * @param requestFn 基本请求函数
 * @param config 重试配置项
 * @returns 新的请求函数
 */
export function useRetry(requestFn: (config: HttpMethodDecoratorConfig) => Promise<any>, config: RetryOptions) {
  // 实现请求重传
  return async (config: HttpMethodDecoratorConfig) => {
    // 实现重试逻辑
    {
      // ... 重试逻辑
      return requestFn(config);
      // ...
    }
  };
}
```

```js [HttpMethodDecoratorConfig]
// 这个其实在基本请求方法中就介绍过，它建立在`axios`配置的基础上，添加了一些额外的配置项，如`retry`、`debounce`、`throttle`等，
export class HttpMethodDecoratorConfig<D = any> implements AxiosRequestConfig<D>, AxiosPlusRequestConfig {
  /**
   * axios引用
   */
  refAxios?: AxiosInstance;
  /**
   * 请求重传
   */
  retry?: RetryConfig;
  /**
   * 自定义重传方式
   */
  customRetry?: RetryRequestPolicy;
  /**
   * 防抖
   */
  debounce?: DebounceConfig;
  /**
   * 自定义防抖
   */
  customDebounce?: DebounceRequestPolicy;
  /**
   * 节流
   */
  throttle?: ThrottleConfig;
  /**
   * 自定义节流
   */
  customThrottle?: ThrottleRequestPolicy;
  /**
   * mock
   */
  mock?: MockConfig | HttpResponseResolver<PathParams, DefaultBodyType, undefined>;
  /**
   * mockhandlers
   */
  mockHandlers?: MockHandlers;
}
```

```js [RetryOptions]
/**
 * retry选项
 */
export type RetryOptions = {
  /**
   * 请求重传次数
   */
  count?: number,
  /**
   * 请求重传延时(单位ms)
   */
  delay?: number,
  /**
   * 信号量
   */
  signal?: Signal,
};
/**
 * 请求重传配置
 */
export type RetryConfig =
  | RetryOptions
  | boolean // 是否开启，开启则采用默认值
  | number // 请求重传的次数
  | Signal
  | [number, number]; // 请求重传次数和延时（基础延时）
```

:::
::: tip 装饰器模式
从本质来讲`axios-plus`采用了**装饰器模式**来实现请求功能的增强，外层请求函数包裹内层请求函数一层包裹一层（就像套娃一样），最终返回一个新的请求函数，然后利用这个新的请求函数发起请求。
![装饰器模式](https://image-bucket-1307756649.cos.ap-chengdu.myqcloud.com/image/20251029160152919.png)
:::

### 重要特性

- `axios-plus`采用指数退避策略：第 `n` 次重试的延迟时间为 `delay * 2^(n-1)`
- `axios-plus`不会对请求重发次数进行限制，且首次重试无延迟，从第二次开始应用延迟策略

### 适用场景

- 网络请求偶尔失败的接口
- 非实时性要求的接口
- 对成功率要求较高的场景

::: warning 请求幂等性与`post`请求
不推荐在`Post`请求中使用请求重发功能，因为`Post`请求一般不具有幂等性，重试可能会导致数据重复。
:::

## 防抖（Debounce）

### 基本使用

防抖功能用于限制短时间内多次触发的请求，只执行最后一次请求，适用于频繁触发的场景。基本使用如下所示：

```typescript

```

### 配置方式

```typescript
// 1. 仅指定延迟时间(ms)
@Get({
  url: '/search',
  debounce: 300 // 300ms内多次调用只执行最后一次
})

// 2. 完整配置
@Get({
  url: '/search',
  debounce: {
    delay: 300,      // 延迟时间
    immediate: false, // 是否立即执行第一次请求
    signal: abortSignal // 取消信号
  }
})

// 3. 使用装饰器单独配置
@Get('/search')
@Debounce(300)
search() {}
```

### 实现原理

- 维护一个定时器，每次触发时重置定时器
- 延迟时间结束后执行最后一次请求
- `immediate: true` 时会立即执行第一次请求，后续触发才进入防抖逻辑

### 适用场景

- 搜索框输入联想
- 窗口大小调整触发的请求
- 频繁点击按钮的场景

## 节流（Throttle）

节流功能用于限制请求的执行频率，确保在指定时间间隔内只执行一次，适用于持续触发的场景。

### 配置方式

```typescript
// 1. 仅指定间隔时间(ms)
@Get({
  url: '/scroll',
  throttle: 1000 // 1秒内最多执行一次
})

// 2. 完整配置
@Get({
  url: '/scroll',
  throttle: {
    interval: 1000, // 间隔时间
    signal: abortSignal // 取消信号
  }
})

// 3. 使用装饰器单独配置
@Get('/scroll')
@Throttle(1000)
loadMore() {}
```

### 实现原理

- 记录上次执行时间，每次触发时检查时间间隔
- 间隔时间内的触发会排队等待，间隔结束后执行最后一次触发
- 首次触发会立即执行，无需等待

### 适用场景

- 滚动加载更多数据
- 拖拽操作触发的请求
- 实时数据刷新（如仪表盘）

## 执行顺序与冲突说明

### 执行顺序

当同时配置多种功能时，执行顺序固定为：

```
防抖(Debounce) → 节流(Throttle) → 请求重发(Retry) → 实际请求
```

这是由内部实现逻辑决定的，从用户触发到实际请求会依次经过这些策略处理。

### 不兼容组合

1. **防抖与节流不能同时使用**

   - 两者都是流量控制策略，同时使用会导致逻辑冲突
   - 框架会检测这种冲突并抛出警告
   - 建议根据具体场景选择更适合的一种

2. **注意事项**
   - 重传功能可以与防抖/节流同时使用，因为它作用于请求失败后的重试逻辑
   - 当使用自定义策略（`customDebounce`/`customThrottle`/`customRetry`）时，仍需遵守上述冲突规则
   - 信号量（`signal`）可以同时控制多种策略的取消

### 推荐组合

- 搜索场景：`防抖 + 重传`
- 滚动加载：`节流 + 重传`
- 普通接口：`仅重传`（大多数场景）

这些组合既能保证用户体验，又能提高请求成功率，同时避免策略冲突。
