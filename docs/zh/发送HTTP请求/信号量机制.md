# 信号量机制（Signal & SignalController）

在 `axios-plus` 中，信号量机制主要用于对请求流程进行精细化控制，如取消重试、防抖、节流或 mock 等操作，通过 `Signal` 和 `SignalController` 类实现。

## 核心类与功能

### 1. `Signal` 类（信号量本体）

定义了信号量的基础状态和操作，用于标记「是否取消」某个流程。

```typescript
/**
 * 信号量
 */
export class Signal {
  /** 是否取消的状态标记 */
  private aborted: boolean = false;

  /**
   * 检查是否已取消
   * @returns boolean - 已取消返回 true，否则 false
   */
  isAborted() {
    return this.aborted;
  }

  /** 标记为取消状态 */
  abort() {
    this.aborted = true;
  }

  /** 重置为启用状态（取消「取消标记」） */
  enable() {
    this.aborted = false;
  }
}
```

**核心作用**：通过 `aborted` 状态标记控制流程，外部可通过 `isAborted()` 检查状态，通过 `abort()`/`enable()` 切换状态。

### 2. `SignalController` 类（信号量控制器）

用于创建和管理 `Signal` 实例，提供更便捷的状态操作接口。

```typescript
import { Signal } from './Signal';

/**
 * 信号量控制器
 */
export class SignalController {
  /** 内部维护的信号量实例 */
  private _signal: Signal;

  /** 访问信号量实例的只读属性 */
  get signal() {
    return this._signal;
  }

  constructor() {
    this._signal = new Signal();
  }

  /**
   * 触发信号量取消
   * @param message - 可选消息（未实际使用，预留扩展）
   */
  abort(message: string = '') {
    this.signal.abort();
  }

  /** 重置信号量为启用状态 */
  enable() {
    this.signal.enable();
  }
}
```

**核心作用**：封装 `Signal` 的创建和操作，通过 `controller.signal` 暴露信号量实例，通过 `abort()`/`enable()` 间接控制状态。

## 与请求功能的结合使用

信号量可用于控制 **重试、防抖、节流、mock** 等功能的触发与取消，以下是典型场景：

### 1. 控制重试（Retry）

通过信号量手动取消重试流程：

```typescript
import { Get, Retry } from 'axios-plus';
import { SignalController } from './core/common/signal/SignalController';

// 创建信号量控制器
const retryController = new SignalController();

class Api {
  @Get({
    url: '/data',
    retry: {
      count: 3,
      delay: 1000,
      signal: retryController.signal, // 关联信号量
    },
  })
  fetchData() {}
}

// 手动取消重试（例如用户主动中断）
retryController.abort();
```

**原理**：重试逻辑会定期检查 `signal.isAborted()`，若为 `true` 则停止重试。

### 2. 控制防抖（Debounce）

在防抖延迟期间取消请求：

```typescript
import { Post, Debounce } from 'axios-plus';
import { SignalController } from './core/common/signal/SignalController';

const debounceController = new SignalController();

class Api {
  @Post({
    url: '/search',
    debounce: {
      delay: 300,
      signal: debounceController.signal, // 关联信号量
    },
  })
  search() {}
}

// 取消当前防抖队列中的请求
debounceController.abort();
```

**原理**：防抖触发时会先检查信号量状态，若已取消则直接执行原请求（跳过防抖延迟）。

### 3. 控制节流（Throttle）

动态取消节流限制：

```typescript
import { Get, Throttle } from 'axios-plus';
import { SignalController } from './core/common/signal/SignalController';

const throttleController = new SignalController();

class Api {
  @Get({
    url: '/scroll',
    throttle: {
      interval: 1000,
      signal: throttleController.signal, // 关联信号量
    },
  })
  loadMore() {}
}

// 取消节流限制（立即执行后续请求）
throttleController.abort();
```

**原理**：节流逻辑中，若检测到信号量已取消，则直接执行请求，不再限制频率。

### 4. 控制 Mock

动态关闭 mock 功能：

```typescript
import { Get, Mock } from 'axios-plus';
import { SignalController } from './core/common/signal/SignalController';

const mockController = new SignalController();

class Api {
  @Get('/users')
  @Mock({
    handlers: () => ({ code: 200, data: [] }),
    signal: mockController.signal, // 关联信号量
  })
  getUsers() {}
}

// 关闭 mock（后续请求走真实接口）
mockController.abort();
```

**原理**：mock 逻辑执行前会检查信号量，若已取消则跳过 mock，直接发送真实请求。

## 信号量的传递与共享

- 一个 `SignalController` 可关联多个请求功能（如同时控制重试和防抖）。
- 可通过共享 `Signal` 实例实现多请求的统一控制（例如页面卸载时取消所有未完成的请求流程）。

```typescript
// 全局信号量控制器（控制所有关联的请求功能）
const globalController = new SignalController();

// 多个请求共享同一信号量
class Api {
  @Get({ url: '/data1', retry: { signal: globalController.signal } })
  fetch1() {}

  @Post({ url: '/data2', debounce: { signal: globalController.signal } })
  fetch2() {}
}

// 页面卸载时取消所有关联的流程
window.addEventListener('unload', () => {
  globalController.abort();
});
```

## 总结

信号量机制是 `axios-plus` 中用于精细化控制请求流程的核心工具，通过 `Signal`（状态存储）和 `SignalController`（状态管理）实现：

- **核心能力**：标记并切换「取消/启用」状态，供请求功能（重试、防抖等）判断是否继续执行。
- **典型场景**：手动中断重试、取消防抖延迟、解除节流限制、动态关闭 mock 等。
- **优势**：灵活控制单个或多个请求的生命周期，提升用户体验（如避免无效请求浪费资源）。
