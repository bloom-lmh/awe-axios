# 自定义常用功能

`axios-plus` 允许你自定义一些功能，如节流、防抖、重试等，可以通过配置项注入到请求函数中，实现一些常用功能。

## 规范

自定义功能（如节流、防抖、重试等）需遵循以下规范，以确保与框架无缝集成：

必须符合框架定义的策略函数类型，确保参数和返回值格式一致：

```typescript
// 节流策略类型（框架内置）
type ThrottleRequestPolicy = (
  requestFn: (config: HttpMethodDecoratorConfig) => Promise<any>,
  config: ThrottleOptions,
) => (config: HttpMethodDecoratorConfig) => Promise<any>;

// 防抖策略类型（框架内置）
type DebounceRequestPolicy = (
  requestFn: (config: HttpMethodDecoratorConfig) => Promise<any>,
  config: DebounceOptions,
) => (config: HttpMethodDecoratorConfig) => Promise<any>;

// 重试策略类型（框架内置）
type RetryRequestPolicy = (
  requestFn: (config: HttpMethodDecoratorConfig) => Promise<any>,
  config: RetryOptions,
) => (config: HttpMethodDecoratorConfig) => Promise<any>;
```

核心要求

- 接收原始请求函数（`requestFn`）和配置（`config`）作为参数
- 返回一个新的请求函数，该函数接收请求配置并返回 Promise
- 必须兼容信号量机制（`signal`），在信号量取消时能正确处理
- 不得修改原始请求配置的核心属性（如 `url`、`method` 等）

最终通过 `customThrottle`、`customDebounce`、`customRetry` 配置项注入，优先级高于框架默认实现

## 自定义节流（Custom Throttle）

### 实现示例：带最大等待次数的节流

```typescript
import { ThrottleOptions, ThrottleRequestPolicy } from './core/httpMethod/types/httpMethod';
import { HttpMethodDecoratorConfig } from './core/httpMethod/types/HttpMethodDecoratorConfig';

/**
 * 带最大等待次数的节流实现
 * @param maxWaitCount 最大等待次数，超过后强制执行
 */
export function createMaxWaitThrottle(maxWaitCount: number): ThrottleRequestPolicy {
  return (requestFn, config) => {
    let { interval, signal } = config;
    let lastTime = 0;
    let timer: any = null;
    let waitCount = 0; // 等待次数计数器
    let pendingArgs: HttpMethodDecoratorConfig | null = null;
    let pendingResolve: ((value: any) => void) | null = null;
    let pendingReject: ((reason?: any) => void) | null = null;

    const run = async () => {
      if (!pendingArgs || !pendingResolve) return;

      try {
        const result = await requestFn(pendingArgs);
        lastTime = Date.now();
        pendingResolve(result);
      } catch (error) {
        pendingReject?.(error);
      } finally {
        timer = null;
        pendingArgs = null;
        pendingResolve = null;
        pendingReject = null;
        waitCount = 0; // 重置等待次数
      }
    };

    return async currentConfig => {
      // 信号量取消时直接执行
      if (signal.isAborted()) {
        return await requestFn(currentConfig);
      }

      const currentTime = Date.now();
      const elapsed = currentTime - lastTime;

      // 首次调用或间隔时间已到，直接执行
      if (lastTime === 0 || elapsed >= interval) {
        lastTime = currentTime;
        return await requestFn(currentConfig);
      }

      // 记录当前请求参数
      pendingArgs = currentConfig;
      waitCount++;

      // 超过最大等待次数，立即执行
      if (waitCount >= maxWaitCount) {
        clearTimeout(timer);
        lastTime = currentTime;
        waitCount = 0;
        return await requestFn(currentConfig);
      }

      // 未超过则等待剩余时间
      if (!timer) {
        const remainTime = interval - elapsed;
        timer = setTimeout(run, remainTime);
      }

      return new Promise((resolve, reject) => {
        pendingResolve = resolve;
        pendingReject = reject;
      });
    };
  };
}
```

### 使用方式

```typescript
import { Get } from './core/httpMethod';
import { createMaxWaitThrottle } from './custom-throttle';

class Api {
  @Get({
    url: '/scroll-data',
    throttle: {
      interval: 1000, // 基础间隔1秒
    },
    // 注入自定义节流
    customThrottle: createMaxWaitThrottle(3), // 最多等待3次
  })
  loadScrollData() {}
}
```

## 自定义防抖（Custom Debounce）

### 实现示例：带最小间隔的防抖

```typescript
import { DebounceOptions, DebounceRequestPolicy } from './core/httpMethod/types/httpMethod';
import { HttpMethodDecoratorConfig } from './core/httpMethod/types/HttpMethodDecoratorConfig';

/**
 * 带最小间隔的防抖实现
 * @param minInterval 最小执行间隔（ms），确保不会过于频繁执行
 */
export function createMinIntervalDebounce(minInterval: number): DebounceRequestPolicy {
  return (requestFn, config) => {
    let { delay, immediate, signal } = config;
    let timer: any = null;
    let lastExecuteTime = 0; // 上次实际执行时间

    return async currentConfig => {
      // 信号量取消时直接执行
      if (signal.isAborted()) {
        return await requestFn(currentConfig);
      }

      // 清除现有定时器
      clearTimeout(timer);

      // 立即执行模式（首次）
      if (immediate && lastExecuteTime === 0) {
        lastExecuteTime = Date.now();
        return await requestFn(currentConfig);
      }

      return new Promise((resolve, reject) => {
        // 计算实际延迟时间（确保不小于最小间隔）
        const currentTime = Date.now();
        const elapsed = currentTime - lastExecuteTime;
        const actualDelay = Math.max(delay, Math.max(0, minInterval - elapsed));

        timer = setTimeout(async () => {
          try {
            const result = await requestFn(currentConfig);
            lastExecuteTime = Date.now();
            resolve(result);
          } catch (error) {
            reject(error);
          } finally {
            timer = null;
          }
        }, actualDelay);
      });
    };
  };
}
```

### 使用方式

```typescript
import { Post } from './core/httpMethod';
import { createMinIntervalDebounce } from './custom-debounce';

class SearchApi {
  @Post({
    url: '/search',
    debounce: {
      delay: 300, // 基础防抖延迟
      immediate: true,
    },
    // 注入自定义防抖（最小间隔1秒）
    customDebounce: createMinIntervalDebounce(1000),
  })
  searchKeywords() {}
}
```

## 自定义重试（Custom Retry）

### 实现示例：带状态码过滤的重试

```typescript
import { RetryOptions, RetryRequestPolicy } from './core/httpMethod/types/httpMethod';
import { HttpMethodDecoratorConfig } from './core/httpMethod/types/HttpMethodDecoratorConfig';

/**
 * 带状态码过滤的重试实现
 * @param allowedStatusCodes 允许重试的状态码列表
 */
export function createStatusFilterRetry(allowedStatusCodes: number[]): RetryRequestPolicy {
  return (requestFn, config) => {
    let { count, delay, signal } = config;

    const retry = async (currentConfig: HttpMethodDecoratorConfig, retryCount: number): Promise<any> => {
      try {
        const result = await requestFn(currentConfig);
        return result;
      } catch (error: any) {
        // 信号量取消或达到最大重试次数，终止重试
        if (signal.isAborted() || retryCount >= count) {
          throw error;
        }

        // 只重试指定状态码的错误
        const statusCode = error.response?.status;
        if (!allowedStatusCodes.includes(statusCode)) {
          throw error;
        }

        // 指数退避延迟
        const waitTime = delay * Math.pow(2, retryCount);
        await new Promise(resolve => setTimeout(resolve, waitTime));

        // 递归重试
        return retry(currentConfig, retryCount + 1);
      }
    };

    return currentConfig => {
      return retry(currentConfig, 0);
    };
  };
}
```

### 使用方式

```typescript
import { Get } from './core/httpMethod';
import { createStatusFilterRetry } from './custom-retry';

class DataApi {
  @Get({
    url: '/sensitive-data',
    retry: {
      count: 3,
      delay: 500,
    },
    // 只重试500和502状态码
    customRetry: createStatusFilterRetry([500, 502]),
  })
  fetchSensitiveData() {}
}
```

## 自定义功能的优先级与冲突处理

1. **优先级顺序**：

   - 自定义功能（`customXxx`）> 框架默认实现 > 基础请求

2. **冲突处理**：

   - 自定义节流与自定义防抖仍不能同时使用（框架会检测并抛出警告）
   - 自定义功能需自行处理与信号量的兼容（必须优先响应 `signal.isAborted()`）
   - 多个自定义功能组合时，执行顺序仍遵循：防抖 → 节流 → 重试

3. **调试建议**：
   - 使用 `console.log` 跟踪自定义函数的执行流程
   - 利用信号量 `signal` 测试取消逻辑的正确性
   - 优先测试边界条件（如最大重试次数、最短间隔等）
